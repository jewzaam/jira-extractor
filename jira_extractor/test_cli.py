#!/usr/bin/env python3
# Generated by: Cursor (Claude)
"""
Unit tests for JIRA Extractor CLI

Copyright (C) 2025 Naveen Z. Malik
This program is licensed under GPL-3.0-or-later
"""

import unittest
from unittest.mock import Mock, patch, mock_open
import json
import sys
import requests
import io

from .cli import (
    setup_logging, validate_url, write_output, create_parser, main
)


class TestCLIFunctions(unittest.TestCase):
    """Test cases for CLI utility functions"""
    
    def setUp(self):
        """Set up test fixtures"""
        self.test_url = "https://test.jira.com"
        self.test_issue_key = "TEST-123"
        self.test_data = {
            "key": self.test_issue_key,
            "fields": {
                "summary": "Test Issue Summary",
                "description": "Test description"
            }
        }
    
    @patch('jira_extractor.cli.logging.basicConfig')
    def test_setup_logging_info_level(self, mock_basic_config):
        """Test logging setup with INFO level"""
        setup_logging(debug=False)
        
        mock_basic_config.assert_called_once()
        call_args = mock_basic_config.call_args
        self.assertEqual(call_args[1]['level'], 20)  # logging.INFO
        self.assertIn('%(levelname)s: %(message)s', call_args[1]['format'])
    
    @patch('jira_extractor.cli.logging.basicConfig')
    def test_setup_logging_debug_level(self, mock_basic_config):
        """Test logging setup with DEBUG level"""
        setup_logging(debug=True)
        
        mock_basic_config.assert_called_once()
        call_args = mock_basic_config.call_args
        self.assertEqual(call_args[1]['level'], 10)  # logging.DEBUG
        self.assertIn('%(asctime)s - %(levelname)s: %(message)s', call_args[1]['format'])
    
    def test_validate_url_with_scheme(self):
        """Test URL validation with existing scheme"""
        url = "https://jira.example.com"
        result = validate_url(url)
        self.assertEqual(result, url)
    
    def test_validate_url_without_scheme(self):
        """Test URL validation adds https scheme"""
        url = "jira.example.com"
        result = validate_url(url)
        self.assertEqual(result, f"https://{url}")
    
    def test_validate_url_invalid(self):
        """Test URL validation with invalid URL"""
        with self.assertRaises(ValueError) as cm:
            validate_url("")
        self.assertIn("Invalid URL", str(cm.exception))
    
    @patch('builtins.print')
    def test_write_output_stdout(self, mock_print):
        """Test writing output to stdout"""
        write_output(self.test_data, "-", self.test_issue_key)
        
        mock_print.assert_called_once()
        printed_output = mock_print.call_args[0][0]
        parsed_output = json.loads(printed_output)
        self.assertEqual(parsed_output["key"], self.test_issue_key)
    
    @patch('builtins.print')
    def test_write_output_stdout_explicit(self, mock_print):
        """Test writing output to stdout with explicit 'stdout'"""
        write_output(self.test_data, "stdout", self.test_issue_key)
        
        mock_print.assert_called_once()
        printed_output = mock_print.call_args[0][0]
        parsed_output = json.loads(printed_output)
        self.assertEqual(parsed_output["key"], self.test_issue_key)
    
    @patch('os.makedirs')
    @patch('builtins.open', new_callable=mock_open)
    @patch('builtins.print')
    @patch('os.path.exists')
    @patch('jira_extractor.cli.datetime')
    def test_write_output_metadata_content(self, mock_datetime, mock_exists, mock_print, mock_file, mock_makedirs):
        """Test metadata file content generation"""
        mock_exists.return_value = False
        mock_datetime.now.return_value.isoformat.return_value = "2025-01-01T12:00:00"
        
        data = {
            "key": "TEST-123",
            "fields": {
                "summary": "Test issue summary",
                "issuetype": {"name": "Bug"},
                "status": {"name": "Open"},
                "subtasks": [{"key": "SUB-1"}],
                "issuelinks": [{"type": {"name": "Blocks"}}],
                "comment": {"total": 5}
            }
        }
        
        write_output(data, "/tmp/output", "TEST-123", overwrite=False, expand="changelog,comments")
        
        # Verify that both files were opened (main file and metadata file)
        calls = mock_file.call_args_list
        self.assertEqual(len(calls), 2)
        
        # Verify the file paths
        main_file_path = calls[0][0][0]
        metadata_file_path = calls[1][0][0]
        
        self.assertEqual(main_file_path, "/tmp/output/TEST-123.json")
        self.assertEqual(metadata_file_path, "/tmp/output/TEST-123_metadata.json")
        
        # Verify that json.dump was called for metadata file
        # This is sufficient to test that metadata generation works
        self.assertEqual(mock_file.call_count, 2)

    @patch('builtins.open', new_callable=mock_open)
    @patch('os.makedirs')
    @patch('os.path.exists')
    @patch('builtins.print')
    def test_write_output_file_new(self, mock_print, mock_exists, mock_makedirs, mock_file):
        """Test writing output to new file"""
        mock_exists.return_value = False
        output_dir = "/test/output"
        
        write_output(self.test_data, output_dir, self.test_issue_key)
        
        # Verify directory creation
        mock_makedirs.assert_called_once_with(output_dir, exist_ok=True)
        
        # Verify file creation - both main file and metadata file
        self.assertEqual(mock_file.call_count, 2)
        
        # Check that both files were created
        calls = mock_file.call_args_list
        expected_main_path = f"{output_dir}/{self.test_issue_key}.json"
        expected_metadata_path = f"{output_dir}/{self.test_issue_key}_metadata.json"
        
        self.assertEqual(calls[0][0][0], expected_main_path)
        self.assertEqual(calls[1][0][0], expected_metadata_path)
        
        # Verify main file content - the main issue JSON file should be written correctly
        # Since both files are written, we can't easily distinguish the writes,
        # but we can verify the files were created with correct paths
        self.assertTrue(expected_main_path in str(calls[0]))
        self.assertTrue(expected_metadata_path in str(calls[1]))
        
        # Verify success messages - should be called twice (main file + metadata)
        self.assertEqual(mock_print.call_count, 2)
        
        # Check the messages
        print_calls = mock_print.call_args_list
        expected_main_msg = f"Issue {self.test_issue_key} saved to {expected_main_path}"
        expected_metadata_msg = f"Metadata saved to {expected_metadata_path}"
        
        self.assertEqual(print_calls[0][0][0], expected_main_msg)
        self.assertEqual(print_calls[1][0][0], expected_metadata_msg)
    
    @patch('os.makedirs')
    @patch('os.path.exists')
    def test_write_output_file_exists_no_overwrite(self, mock_exists, mock_makedirs):
        """Test writing output to existing file without overwrite flag"""
        mock_exists.return_value = True
        output_dir = "/test/output"
        
        with self.assertRaises(Exception) as cm:
            write_output(self.test_data, output_dir, self.test_issue_key, overwrite=False)
        
        self.assertIn("already exists", str(cm.exception))
        self.assertIn("--overwrite", str(cm.exception))
    
    @patch('builtins.open', new_callable=mock_open)
    @patch('os.makedirs')
    @patch('os.path.exists')
    @patch('builtins.print')
    def test_write_output_file_exists_with_overwrite(self, mock_print, mock_exists, mock_makedirs, mock_file):
        """Test writing output to existing file with overwrite flag"""
        mock_exists.return_value = True
        output_dir = "/test/output"
        
        write_output(self.test_data, output_dir, self.test_issue_key, overwrite=True)
        
        # Should still proceed and write both files
        self.assertEqual(mock_file.call_count, 2)
        
        # Check that both files were created
        calls = mock_file.call_args_list
        expected_main_path = f"{output_dir}/{self.test_issue_key}.json"
        expected_metadata_path = f"{output_dir}/{self.test_issue_key}_metadata.json"
        
        self.assertEqual(calls[0][0][0], expected_main_path)
        self.assertEqual(calls[1][0][0], expected_metadata_path)


class TestArgumentParser(unittest.TestCase):
    """Test cases for argument parser configuration"""
    
    def setUp(self):
        """Set up test fixtures"""
        self.parser = create_parser()
    
    def test_parser_required_args(self):
        """Test parser with required arguments"""
        args = self.parser.parse_args([
            '-u', 'https://jira.example.com',
            '-i', 'TEST-123'
        ])
        
        self.assertEqual(args.url, 'https://jira.example.com')
        self.assertEqual(args.issue, 'TEST-123')
    
    def test_parser_missing_url(self):
        """Test parser with missing required URL"""
        with self.assertRaises(SystemExit):
            self.parser.parse_args(['-i', 'TEST-123'])
    
    def test_parser_missing_issue(self):
        """Test parser with missing required issue"""
        with self.assertRaises(SystemExit):
            self.parser.parse_args(['-u', 'https://jira.example.com'])
    
    def test_parser_bearer_token(self):
        """Test parser with bearer token authentication"""
        args = self.parser.parse_args([
            '-u', 'https://jira.example.com',
            '-i', 'TEST-123',
            '--bearer-token', 'abc123'
        ])
        
        self.assertEqual(args.bearer_token, 'abc123')
    
    def test_parser_token_auth(self):
        """Test parser with API token authentication"""
        args = self.parser.parse_args([
            '-u', 'https://jira.example.com',
            '-i', 'TEST-123',
            '--username', 'testuser',
            '--token', 'token123'
        ])
        
        self.assertEqual(args.username, 'testuser')
        self.assertEqual(args.token, 'token123')
    
    def test_parser_password_auth(self):
        """Test parser with password authentication"""
        args = self.parser.parse_args([
            '-u', 'https://jira.example.com',
            '-i', 'TEST-123',
            '--username', 'testuser',
            '--password', 'pass123'
        ])
        
        self.assertEqual(args.username, 'testuser')
        self.assertEqual(args.password, 'pass123')
    
    def test_parser_output_options(self):
        """Test parser with output options"""
        args = self.parser.parse_args([
            '-u', 'https://jira.example.com',
            '-i', 'TEST-123',
            '-o', './output',
            '--overwrite'
        ])
        
        self.assertEqual(args.output, './output')
        self.assertTrue(args.overwrite)
    
    def test_parser_field_options(self):
        """Test parser with field expansion options"""
        args = self.parser.parse_args([
            '-u', 'https://jira.example.com',
            '-i', 'TEST-123',
            '--expand', 'changelog,comments'
        ])
        
        self.assertEqual(args.expand, 'changelog,comments')
    
    def test_parser_debug_option(self):
        """Test parser with debug option"""
        args = self.parser.parse_args([
            '-u', 'https://jira.example.com',
            '-i', 'TEST-123',
            '--debug'
        ])
        
        self.assertTrue(args.debug)


class TestMainFunction(unittest.TestCase):
    """Test cases for main function"""
    
    @patch('jira_extractor.cli.JiraClient')
    @patch('jira_extractor.cli.write_output')
    @patch('jira_extractor.cli.setup_logging')
    @patch('sys.argv')
    def test_main_bearer_auth_success(self, mock_argv, mock_setup_logging, mock_write_output, mock_jira_client):
        """Test main function with successful bearer authentication"""
        # Setup command line arguments
        mock_argv.__getitem__.side_effect = lambda x: [
            'jira_extractor.py',
            '-u', 'https://jira.example.com',
            '-i', 'TEST-123',
            '--bearer-token', 'abc123'
        ][x]
        mock_argv.__len__.return_value = 5
        
        # Setup mocks
        mock_client_instance = Mock()
        mock_client_instance.get_issue.return_value = {"key": "TEST-123"}
        mock_jira_client.return_value = mock_client_instance
        
        with patch('argparse.ArgumentParser.parse_args') as mock_parse_args:
            mock_args = Mock()
            mock_args.url = 'https://jira.example.com'
            mock_args.issue = 'TEST-123'
            mock_args.bearer_token = 'abc123'
            mock_args.token = None
            mock_args.username = None
            mock_args.password = None
            mock_args.output = '-'
            mock_args.overwrite = False
            mock_args.expand = None
            mock_args.debug = False
            mock_args.descendant_depth = '0'
            mock_args.include_subtasks = False
            mock_args.include_links = False
            mock_args.include_remote_links = False
            mock_parse_args.return_value = mock_args
            
            main()
            
            # Verify client creation
            mock_jira_client.assert_called_once_with(
                'https://jira.example.com',
                'bearer',
                token='abc123'
            )
            
            # Verify issue retrieval
            mock_client_instance.get_issue.assert_called_once_with('TEST-123', expand=None)
            
            # Verify output writing
            mock_write_output.assert_called_once()
    
    @patch('jira_extractor.cli.JiraClient')
    @patch('jira_extractor.cli.setup_logging')
    @patch('sys.argv')
    @patch('builtins.print')
    def test_main_token_auth_missing_username(self, mock_print, mock_argv, mock_setup_logging, mock_jira_client):
        """Test main function with token auth but missing username"""
        mock_argv.__getitem__.side_effect = lambda x: [
            'jira_extractor.py',
            '-u', 'https://jira.example.com',
            '-i', 'TEST-123',
            '--token', 'abc123'
        ][x]
        mock_argv.__len__.return_value = 5
        
        with patch('argparse.ArgumentParser.parse_args') as mock_parse_args:
            mock_args = Mock()
            mock_args.url = 'https://jira.example.com'
            mock_args.issue = 'TEST-123'
            mock_args.bearer_token = None
            mock_args.token = 'abc123'
            mock_args.username = None
            mock_args.password = None
            mock_args.debug = False
            mock_args.descendant_depth = '0'
            mock_args.include_subtasks = False
            mock_args.include_links = False
            mock_args.include_remote_links = False
            mock_parse_args.return_value = mock_args
            
            with self.assertRaises(SystemExit):
                main()
            
            # Verify error message
            mock_print.assert_called_with(
                "Error: --username is required when using --token",
                file=sys.stderr
            )
    
    @patch('jira_extractor.cli.JiraClient')
    @patch('jira_extractor.cli.setup_logging')
    @patch('sys.argv')
    @patch('builtins.print')
    def test_main_no_auth_public_issue(self, mock_print, mock_argv, mock_setup_logging, mock_jira_client):
        """Test main function with no authentication for public issue"""
        mock_argv.__getitem__.side_effect = lambda x: [
            'jira_extractor.py',
            '-u', 'https://issues.redhat.com',
            '-i', 'RFE-7877'
        ][x]
        mock_argv.__len__.return_value = 3
        
        # Setup mocks
        mock_client_instance = Mock()
        mock_client_instance.get_issue.return_value = {"key": "RFE-7877"}
        mock_jira_client.return_value = mock_client_instance
        
        with patch('argparse.ArgumentParser.parse_args') as mock_parse_args, \
             patch('jira_extractor.cli.write_output') as mock_write_output:
            mock_args = Mock()
            mock_args.url = 'https://issues.redhat.com'
            mock_args.issue = 'RFE-7877'
            mock_args.bearer_token = None
            mock_args.token = None
            mock_args.username = None
            mock_args.password = None
            mock_args.output = '-'
            mock_args.overwrite = False
            mock_args.expand = None
            mock_args.debug = False
            mock_args.descendant_depth = '0'
            mock_args.include_subtasks = False
            mock_args.include_links = False
            mock_args.include_remote_links = False
            mock_parse_args.return_value = mock_args
            
            main()
            
            # Verify client creation with no auth
            mock_jira_client.assert_called_once_with(
                'https://issues.redhat.com',
                None
            )
            
            # Verify no connection test was performed
            mock_client_instance.test_connection.assert_not_called()
            
            # Verify output was written
            mock_write_output.assert_called_once()
    
    @patch('jira_extractor.cli.validate_url')
    @patch('jira_extractor.cli.setup_logging')
    @patch('sys.argv')
    @patch('builtins.print')
    def test_main_invalid_url(self, mock_print, mock_argv, mock_setup_logging, mock_validate_url):
        """Test main function with invalid URL"""
        mock_validate_url.side_effect = ValueError("Invalid URL: bad-url")
        
        with patch('argparse.ArgumentParser.parse_args') as mock_parse_args:
            mock_args = Mock()
            mock_args.url = 'bad-url'
            mock_args.debug = False
            mock_args.descendant_depth = '0'
            mock_args.include_subtasks = False
            mock_args.include_links = False
            mock_args.include_remote_links = False
            mock_parse_args.return_value = mock_args
            
            with self.assertRaises(SystemExit):
                main()
            
            # Verify error message
            mock_print.assert_called_with(
                "Error: Invalid URL: bad-url",
                file=sys.stderr
            )
    
    @patch('jira_extractor.cli.JiraClient')
    @patch('jira_extractor.cli.setup_logging')
    @patch('sys.argv')
    @patch('builtins.print')
    def test_main_token_auth_success(self, mock_print, mock_argv, mock_setup_logging, mock_jira_client):
        """Test main function with successful token authentication"""
        mock_argv.__getitem__.side_effect = lambda x: [
            'jira_extractor.py',
            '-u', 'https://jira.example.com',
            '-i', 'TEST-123',
            '--username', 'testuser',
            '--token', 'abc123'
        ][x]
        mock_argv.__len__.return_value = 6
        
        # Setup mocks
        mock_client_instance = Mock()
        mock_client_instance.get_issue.return_value = {"key": "TEST-123"}
        mock_client_instance.test_connection.return_value = {"displayName": "Test User"}
        mock_jira_client.return_value = mock_client_instance
        
        with patch('argparse.ArgumentParser.parse_args') as mock_parse_args, \
             patch('jira_extractor.cli.write_output') as mock_write_output:
            mock_args = Mock()
            mock_args.url = 'https://jira.example.com'
            mock_args.issue = 'TEST-123'
            mock_args.bearer_token = None
            mock_args.token = 'abc123'
            mock_args.username = 'testuser'
            mock_args.password = None
            mock_args.output = '-'
            mock_args.overwrite = False
            mock_args.expand = None
            mock_args.debug = False
            mock_args.descendant_depth = '0'
            mock_args.include_subtasks = False
            mock_args.include_links = False
            mock_args.include_remote_links = False
            mock_parse_args.return_value = mock_args
            
            main()
            
            # Verify client creation with token auth
            mock_jira_client.assert_called_once_with(
                'https://jira.example.com',
                'token',
                username='testuser',
                token='abc123'
            )
            
            # Verify connection test was performed
            mock_client_instance.test_connection.assert_called_once()
            
            # Verify output was written
            mock_write_output.assert_called_once()
    
    @patch('jira_extractor.cli.JiraClient')
    @patch('jira_extractor.cli.setup_logging')
    @patch('sys.argv')
    @patch('builtins.print')
    @patch('getpass.getpass')
    def test_main_basic_auth_password_prompt(self, mock_getpass, mock_print, mock_argv, mock_setup_logging, mock_jira_client):
        """Test main function with basic auth and password prompt"""
        mock_getpass.return_value = 'prompted_password'
        mock_argv.__getitem__.side_effect = lambda x: [
            'jira_extractor.py',
            '-u', 'https://jira.example.com',
            '-i', 'TEST-123',
            '--username', 'testuser'
        ][x]
        mock_argv.__len__.return_value = 5
        
        # Setup mocks
        mock_client_instance = Mock()
        mock_client_instance.get_issue.return_value = {"key": "TEST-123"}
        mock_client_instance.test_connection.return_value = {"displayName": "Test User"}
        mock_jira_client.return_value = mock_client_instance
        
        with patch('argparse.ArgumentParser.parse_args') as mock_parse_args, \
             patch('jira_extractor.cli.write_output') as mock_write_output:
            mock_args = Mock()
            mock_args.url = 'https://jira.example.com'
            mock_args.issue = 'TEST-123'
            mock_args.bearer_token = None
            mock_args.token = None
            mock_args.username = 'testuser'
            mock_args.password = None
            mock_args.output = '-'
            mock_args.overwrite = False
            mock_args.expand = None
            mock_args.debug = False
            mock_args.descendant_depth = '0'
            mock_args.include_subtasks = False
            mock_args.include_links = False
            mock_args.include_remote_links = False
            mock_parse_args.return_value = mock_args
            
            main()
            
            # Verify password was prompted
            mock_getpass.assert_called_once_with("Password: ")
            
            # Verify client creation with basic auth
            mock_jira_client.assert_called_once_with(
                'https://jira.example.com',
                'basic',
                username='testuser',
                password='prompted_password'
            )
            
            # Verify output was written
            mock_write_output.assert_called_once()
    
    @patch('jira_extractor.cli.JiraClient')
    @patch('jira_extractor.cli.setup_logging')
    @patch('sys.argv')
    @patch('builtins.print')
    def test_main_basic_auth_missing_username(self, mock_print, mock_argv, mock_setup_logging, mock_jira_client):
        """Test main function with basic auth but missing username"""
        mock_argv.__getitem__.side_effect = lambda x: [
            'jira_extractor.py',
            '-u', 'https://jira.example.com',
            '-i', 'TEST-123',
            '--password', 'secret'
        ][x]
        mock_argv.__len__.return_value = 5
        
        with patch('argparse.ArgumentParser.parse_args') as mock_parse_args:
            mock_args = Mock()
            mock_args.url = 'https://jira.example.com'
            mock_args.issue = 'TEST-123'
            mock_args.bearer_token = None
            mock_args.token = None
            mock_args.username = None
            mock_args.password = 'secret'
            mock_args.debug = False
            mock_args.descendant_depth = '0'
            mock_args.include_subtasks = False
            mock_args.include_links = False
            mock_args.include_remote_links = False
            mock_parse_args.return_value = mock_args
            
            with self.assertRaises(SystemExit):
                main()
            
            # Verify error message
            mock_print.assert_called_with(
                "Error: --username is required for password authentication",
                file=sys.stderr
            )
    
    @patch('jira_extractor.cli.JiraClient')
    @patch('jira_extractor.cli.setup_logging')
    @patch('sys.argv')
    @patch('builtins.print')
    def test_main_connection_error(self, mock_print, mock_argv, mock_setup_logging, mock_jira_client):
        """Test main function with connection error"""
        mock_argv.__getitem__.side_effect = lambda x: [
            'jira_extractor.py',
            '-u', 'https://jira.example.com',
            '-i', 'TEST-123',
            '--bearer-token', 'abc123'
        ][x]
        mock_argv.__len__.return_value = 5
        
        # Setup mocks
        mock_client_instance = Mock()
        mock_client_instance.get_issue.side_effect = requests.exceptions.ConnectionError("Connection failed")
        mock_jira_client.return_value = mock_client_instance
        
        with patch('argparse.ArgumentParser.parse_args') as mock_parse_args:
            mock_args = Mock()
            mock_args.url = 'https://jira.example.com'
            mock_args.issue = 'TEST-123'
            mock_args.bearer_token = 'abc123'
            mock_args.token = None
            mock_args.username = None
            mock_args.password = None
            mock_args.output = '-'
            mock_args.overwrite = False
            mock_args.expand = None
            mock_args.debug = False
            mock_args.descendant_depth = '0'
            mock_args.include_subtasks = False
            mock_args.include_links = False
            mock_args.include_remote_links = False
            mock_parse_args.return_value = mock_args
            
            with self.assertRaises(SystemExit):
                main()
            
            # Verify error message
            mock_print.assert_called_with(
                "Error: Failed to connect to JIRA at https://jira.example.com",
                file=sys.stderr
            )
    
    @patch('jira_extractor.cli.JiraClient')
    @patch('jira_extractor.cli.setup_logging')
    @patch('sys.argv')
    @patch('builtins.print')
    def test_main_timeout_error(self, mock_print, mock_argv, mock_setup_logging, mock_jira_client):
        """Test main function with timeout error"""
        mock_argv.__getitem__.side_effect = lambda x: [
            'jira_extractor.py',
            '-u', 'https://jira.example.com',
            '-i', 'TEST-123',
            '--bearer-token', 'abc123'
        ][x]
        mock_argv.__len__.return_value = 5
        
        # Setup mocks
        mock_client_instance = Mock()
        mock_client_instance.get_issue.side_effect = requests.exceptions.Timeout("Request timed out")
        mock_jira_client.return_value = mock_client_instance
        
        with patch('argparse.ArgumentParser.parse_args') as mock_parse_args:
            mock_args = Mock()
            mock_args.url = 'https://jira.example.com'
            mock_args.issue = 'TEST-123'
            mock_args.bearer_token = 'abc123'
            mock_args.token = None
            mock_args.username = None
            mock_args.password = None
            mock_args.output = '-'
            mock_args.overwrite = False
            mock_args.expand = None
            mock_args.debug = False
            mock_args.descendant_depth = '0'
            mock_args.include_subtasks = False
            mock_args.include_links = False
            mock_args.include_remote_links = False
            mock_parse_args.return_value = mock_args
            
            with self.assertRaises(SystemExit):
                main()
            
            # Verify error message
            mock_print.assert_called_with(
                "Error: Request timed out",
                file=sys.stderr
            )
    
    @patch('jira_extractor.cli.JiraClient')
    @patch('jira_extractor.cli.setup_logging')
    @patch('sys.argv')
    @patch('builtins.print')
    def test_main_http_error(self, mock_print, mock_argv, mock_setup_logging, mock_jira_client):
        """Test main function with HTTP error"""
        mock_argv.__getitem__.side_effect = lambda x: [
            'jira_extractor.py',
            '-u', 'https://jira.example.com',
            '-i', 'TEST-123',
            '--bearer-token', 'abc123'
        ][x]
        mock_argv.__len__.return_value = 5
        
        # Setup mocks
        mock_client_instance = Mock()
        mock_client_instance.get_issue.side_effect = requests.exceptions.HTTPError("HTTP 500 Error")
        mock_jira_client.return_value = mock_client_instance
        
        with patch('argparse.ArgumentParser.parse_args') as mock_parse_args:
            mock_args = Mock()
            mock_args.url = 'https://jira.example.com'
            mock_args.issue = 'TEST-123'
            mock_args.bearer_token = 'abc123'
            mock_args.token = None
            mock_args.username = None
            mock_args.password = None
            mock_args.output = '-'
            mock_args.overwrite = False
            mock_args.expand = None
            mock_args.debug = False
            mock_args.descendant_depth = '0'
            mock_args.include_subtasks = False
            mock_args.include_links = False
            mock_args.include_remote_links = False
            mock_parse_args.return_value = mock_args
            
            with self.assertRaises(SystemExit):
                main()
            
            # Verify error message
            mock_print.assert_called_with(
                "Error: HTTP error: HTTP 500 Error",
                file=sys.stderr
            )
    
    @patch('jira_extractor.cli.JiraClient')
    @patch('jira_extractor.cli.setup_logging')
    @patch('sys.argv')
    @patch('builtins.print')
    @patch('logging.exception')
    def test_main_generic_error_with_debug(self, mock_log_exception, mock_print, mock_argv, mock_setup_logging, mock_jira_client):
        """Test main function with generic error and debug enabled"""
        mock_argv.__getitem__.side_effect = lambda x: [
            'jira_extractor.py',
            '-u', 'https://jira.example.com',
            '-i', 'TEST-123',
            '--bearer-token', 'abc123',
            '--debug'
        ][x]
        mock_argv.__len__.return_value = 6
        
        # Setup mocks
        mock_client_instance = Mock()
        mock_client_instance.get_issue.side_effect = Exception("Generic error")
        mock_jira_client.return_value = mock_client_instance
        
        with patch('argparse.ArgumentParser.parse_args') as mock_parse_args:
            mock_args = Mock()
            mock_args.url = 'https://jira.example.com'
            mock_args.issue = 'TEST-123'
            mock_args.bearer_token = 'abc123'
            mock_args.token = None
            mock_args.username = None
            mock_args.password = None
            mock_args.output = '-'
            mock_args.overwrite = False
            mock_args.expand = None
            mock_args.debug = True
            mock_args.descendant_depth = '0'
            mock_args.include_subtasks = False
            mock_args.include_links = False
            mock_args.include_remote_links = False
            mock_parse_args.return_value = mock_args
            
            with self.assertRaises(SystemExit):
                main()
            
            # Verify error message
            mock_print.assert_called_with(
                "Error: Generic error",
                file=sys.stderr
            )
            
            # Verify debug logging was called
            mock_log_exception.assert_called_once_with("Unexpected error occurred")
    
    @patch('jira_extractor.cli.JiraClient')
    @patch('jira_extractor.cli.setup_logging')
    @patch('sys.argv')
    @patch('builtins.print')
    def test_main_generic_error_without_debug(self, mock_print, mock_argv, mock_setup_logging, mock_jira_client):
        """Test main function with generic error and debug disabled"""
        mock_argv.__getitem__.side_effect = lambda x: [
            'jira_extractor.py',
            '-u', 'https://jira.example.com',
            '-i', 'TEST-123',
            '--bearer-token', 'abc123'
        ][x]
        mock_argv.__len__.return_value = 5
        
        # Setup mocks
        mock_client_instance = Mock()
        mock_client_instance.get_issue.side_effect = Exception("Generic error")
        mock_jira_client.return_value = mock_client_instance
        
        with patch('argparse.ArgumentParser.parse_args') as mock_parse_args:
            mock_args = Mock()
            mock_args.url = 'https://jira.example.com'
            mock_args.issue = 'TEST-123'
            mock_args.bearer_token = 'abc123'
            mock_args.token = None
            mock_args.username = None
            mock_args.password = None
            mock_args.output = '-'
            mock_args.overwrite = False
            mock_args.expand = None
            mock_args.debug = False
            mock_args.descendant_depth = '0'
            mock_args.include_subtasks = False
            mock_args.include_links = False
            mock_args.include_remote_links = False
            mock_parse_args.return_value = mock_args
            
            with self.assertRaises(SystemExit):
                main()
            
            # Verify error message
            mock_print.assert_called_with(
                "Error: Generic error",
                file=sys.stderr
            )
    
    @patch('jira_extractor.cli.JiraClient')
    @patch('jira_extractor.cli.setup_logging')
    @patch('jira_extractor.cli.write_output')
    @patch('sys.argv')
    @patch('builtins.print')
    def test_main_success_with_directory_output(self, mock_print, mock_argv, mock_write_output, mock_setup_logging, mock_jira_client):
        """Test main function with successful execution and directory output"""
        mock_argv.__getitem__.side_effect = lambda x: [
            'jira_extractor.py',
            '-u', 'https://jira.example.com',
            '-i', 'TEST-123',
            '--bearer-token', 'abc123',
            '-o', './output'
        ][x]
        mock_argv.__len__.return_value = 6
        
        # Setup mocks
        mock_client_instance = Mock()
        mock_client_instance.get_issue.return_value = {"key": "TEST-123"}
        mock_client_instance.test_connection.return_value = {"displayName": "Test User"}
        mock_jira_client.return_value = mock_client_instance
        
        with patch('argparse.ArgumentParser.parse_args') as mock_parse_args:
            mock_args = Mock()
            mock_args.url = 'https://jira.example.com'
            mock_args.issue = 'TEST-123'
            mock_args.bearer_token = 'abc123'
            mock_args.token = None
            mock_args.username = None
            mock_args.password = None
            mock_args.output = './output'
            mock_args.overwrite = False
            mock_args.expand = None
            mock_args.debug = False
            mock_args.descendant_depth = '0'
            mock_args.include_subtasks = False
            mock_args.include_links = False
            mock_args.include_remote_links = False
            mock_parse_args.return_value = mock_args
            
            main()
            
            # Verify output was written with new parameters
            mock_write_output.assert_called_once_with(
                {"key": "TEST-123"},
                './output',
                'TEST-123',
                False,
                None
            )


class TestDescendantFunctions(unittest.TestCase):
    """Test cases for descendant extraction functions"""

    def test_parse_depth_valid_integers(self):
        """Test parse_depth with valid integer strings"""
        from jira_extractor.cli import parse_depth
        
        self.assertEqual(parse_depth("0"), 0)
        self.assertEqual(parse_depth("1"), 1)
        self.assertEqual(parse_depth("5"), 5)
        self.assertEqual(parse_depth("100"), 100)

    def test_parse_depth_all_keyword(self):
        """Test parse_depth with 'all' keyword"""
        from jira_extractor.cli import parse_depth
        
        self.assertEqual(parse_depth("all"), -1)
        self.assertEqual(parse_depth("ALL"), -1)
        self.assertEqual(parse_depth("All"), -1)

    def test_parse_depth_invalid_values(self):
        """Test parse_depth with invalid values"""
        from jira_extractor.cli import parse_depth
        
        with self.assertRaises(ValueError) as cm:
            parse_depth("invalid")
        self.assertIn("Invalid depth value: invalid", str(cm.exception))

        with self.assertRaises(ValueError) as cm:
            parse_depth("-1")
        self.assertIn("Use non-negative integer or 'all'", str(cm.exception))

        with self.assertRaises(ValueError) as cm:
            parse_depth("-5")
        self.assertIn("Use non-negative integer or 'all'", str(cm.exception))

    @patch('builtins.print')
    def test_write_multiple_issues_stdout(self, mock_print):
        """Test write_multiple_issues output to stdout"""
        from jira_extractor.cli import write_multiple_issues
        
        issues = {
            "TEST-1": {"key": "TEST-1", "fields": {"summary": "Test Issue 1"}},
            "TEST-2": {"key": "TEST-2", "fields": {"summary": "Test Issue 2"}}
        }
        metadata = {"start_issue": "TEST-1", "total_extracted": 2}
        
        write_multiple_issues(issues, "-", extraction_metadata=metadata)
        
        # Check that print was called with JSON output
        self.assertTrue(mock_print.called)
        printed_output = mock_print.call_args[0][0]
        self.assertIn("extraction_metadata", printed_output)
        self.assertIn("issues", printed_output)
        self.assertIn("TEST-1", printed_output)
        self.assertIn("TEST-2", printed_output)

    def test_write_multiple_issues_stdout_explicit(self):
        """Test write_multiple_issues output to explicit stdout"""
        from jira_extractor.cli import write_multiple_issues
        
        issues = {"TEST-1": {"key": "TEST-1", "fields": {"summary": "Test Issue 1"}}}
        
        with patch('builtins.print') as mock_print:
            write_multiple_issues(issues, "stdout")
            self.assertTrue(mock_print.called)

    @patch('jira_extractor.cli.os.makedirs')
    @patch('builtins.open', new_callable=mock_open)
    @patch('builtins.print')
    def test_write_multiple_issues_directory(self, mock_print, mock_file_open, mock_makedirs):
        """Test write_multiple_issues output to directory"""
        from jira_extractor.cli import write_multiple_issues
        
        issues = {
            "TEST-1": {
                "key": "TEST-1",
                "fields": {
                    "summary": "Test Issue 1",
                    "issuetype": {"name": "Bug"},
                    "status": {"name": "Open"},
                    "subtasks": [],
                    "issuelinks": [],
                    "comment": {"total": 5}
                }
            }
        }
        metadata = {"start_issue": "TEST-1"}
        
        write_multiple_issues(issues, "./output", extraction_metadata=metadata)
        
        # Verify directory creation
        mock_makedirs.assert_called_once_with("./output", exist_ok=True)
        
        # Verify file writes (issue file + metadata file + summary file)
        self.assertEqual(mock_file_open.call_count, 3)
        
        # Verify print statements
        print_calls = [call[0][0] for call in mock_print.call_args_list]
        self.assertTrue(any("Issue TEST-1 saved to" in call for call in print_calls))
        self.assertTrue(any("Extraction summary saved to" in call for call in print_calls))
        self.assertTrue(any("Total issues extracted: 1" in call for call in print_calls))

    @patch('jira_extractor.cli.os.path.exists')
    def test_write_multiple_issues_file_exists_no_overwrite(self, mock_exists):
        """Test write_multiple_issues with existing file and no overwrite"""
        from jira_extractor.cli import write_multiple_issues
        
        issues = {"TEST-1": {"key": "TEST-1", "fields": {"summary": "Test Issue 1"}}}
        mock_exists.return_value = True
        
        with self.assertRaises(Exception) as cm:
            write_multiple_issues(issues, "./output", overwrite=False)
        
        self.assertIn("already exists", str(cm.exception))
        self.assertIn("Use --overwrite", str(cm.exception))

    @patch('jira_extractor.cli.os.makedirs')
    @patch('jira_extractor.cli.os.path.exists')
    @patch('builtins.open', new_callable=mock_open)
    @patch('builtins.print')
    def test_write_multiple_issues_file_exists_with_overwrite(self, mock_print, mock_file_open, mock_exists, mock_makedirs):
        """Test write_multiple_issues with existing file and overwrite enabled"""
        from jira_extractor.cli import write_multiple_issues
        
        issues = {"TEST-1": {"key": "TEST-1", "fields": {"summary": "Test Issue 1", "subtasks": [], "issuelinks": [], "comment": {"total": 0}}}}
        mock_exists.return_value = True
        
        write_multiple_issues(issues, "./output", overwrite=True)
        
        # Should proceed without error
        self.assertTrue(mock_file_open.called)


class TestDescendantArgumentParser(unittest.TestCase):
    """Test cases for descendant-related argument parsing"""

    def test_parser_descendant_depth_option(self):
        """Test parser with descendant depth option"""
        from jira_extractor.cli import create_parser
        
        parser = create_parser()
        args = parser.parse_args([
            '-u', 'https://jira.example.com',
            '-i', 'TEST-123',
            '--descendant-depth', '2',
            '--bearer-token', 'abc123'
        ])
        
        self.assertEqual(args.descendant_depth, '2')
        self.assertEqual(args.url, 'https://jira.example.com')
        self.assertEqual(args.issue, 'TEST-123')

    def test_parser_desc_depth_short_option(self):
        """Test parser with short desc-depth option"""
        from jira_extractor.cli import create_parser
        
        parser = create_parser()
        args = parser.parse_args([
            '-u', 'https://jira.example.com',
            '-i', 'TEST-123',
            '--desc-depth', 'all',
            '--bearer-token', 'abc123'
        ])
        
        self.assertEqual(args.descendant_depth, 'all')

    def test_parser_relationship_options(self):
        """Test parser with relationship traversal options"""
        from jira_extractor.cli import create_parser
        
        parser = create_parser()
        args = parser.parse_args([
            '-u', 'https://jira.example.com',
            '-i', 'TEST-123',
            '--include-subtasks',
            '--include-links',
            '--include-remote-links',
            '--bearer-token', 'abc123'
        ])
        
        self.assertTrue(args.include_subtasks)
        self.assertTrue(args.include_links)
        self.assertTrue(args.include_remote_links)

    def test_parser_descendant_defaults(self):
        """Test parser defaults for descendant options"""
        from jira_extractor.cli import create_parser
        
        parser = create_parser()
        args = parser.parse_args([
            '-u', 'https://jira.example.com',
            '-i', 'TEST-123',
            '--bearer-token', 'abc123'
        ])
        
        self.assertEqual(args.descendant_depth, '0')
        self.assertFalse(args.include_subtasks)
        self.assertFalse(args.include_links)
        self.assertFalse(args.include_remote_links)


class TestMainFunctionDescendants(unittest.TestCase):
    """Test cases for main function with descendant functionality"""

    @patch('jira_extractor.cli.create_parser')
    @patch('jira_extractor.cli.JiraClient')
    @patch('jira_extractor.cli.write_multiple_issues')
    def test_main_descendant_extraction_subtasks(self, mock_write_multiple, mock_jira_client, mock_create_parser):
        """Test main function with descendant extraction including subtasks"""
        from jira_extractor.cli import main
        
        # Setup parser mock
        mock_parser = Mock()
        mock_create_parser.return_value = mock_parser
        
        mock_args = Mock()
        mock_args.url = 'https://jira.example.com'
        mock_args.issue = 'PARENT-1'
        mock_args.bearer_token = 'abc123'
        mock_args.token = None
        mock_args.username = None
        mock_args.password = None
        mock_args.output = '-'
        mock_args.overwrite = False
        mock_args.expand = None
        mock_args.debug = False
        mock_args.descendant_depth = '1'
        mock_args.include_subtasks = True
        mock_args.include_links = False
        mock_args.include_remote_links = False
        mock_parser.parse_args.return_value = mock_args
        
        # Setup client mock
        mock_client_instance = Mock()
        mock_jira_client.return_value = mock_client_instance
        
        # Mock descendants data
        descendants_data = {
            "PARENT-1": {"key": "PARENT-1", "fields": {"summary": "Parent Issue"}},
            "CHILD-1": {"key": "CHILD-1", "fields": {"summary": "Child Issue"}},
            "_extraction_metadata": {
                "start_issue": "PARENT-1",
                "total_issues": 2,
                "include_subtasks": True
            }
        }
        mock_client_instance.get_descendants.return_value = descendants_data
        mock_client_instance.test_connection.return_value = {"displayName": "Test User"}
        
        main()
        
        # Verify client creation and method calls
        mock_jira_client.assert_called_once_with('https://jira.example.com', 'bearer', token='abc123')
        mock_client_instance.get_descendants.assert_called_once_with(
            'PARENT-1',
            depth=1,
            include_subtasks=True,
            include_links=False,
            include_remote_links=False,
            expand=None
        )
        
        # Verify write_multiple_issues called (extraction_metadata removed from issues)
        expected_issues = {
            "PARENT-1": {"key": "PARENT-1", "fields": {"summary": "Parent Issue"}},
            "CHILD-1": {"key": "CHILD-1", "fields": {"summary": "Child Issue"}}
        }
        expected_metadata = {
            "start_issue": "PARENT-1", 
            "total_issues": 2,
            "include_subtasks": True
        }
        mock_write_multiple.assert_called_once_with(
            expected_issues, '-', False, None, expected_metadata
        )

    @patch('jira_extractor.cli.create_parser')
    @patch('jira_extractor.cli.JiraClient')
    @patch('jira_extractor.cli.write_multiple_issues')
    def test_main_descendant_extraction_unlimited_depth(self, mock_write_multiple, mock_jira_client, mock_create_parser):
        """Test main function with unlimited depth descendant extraction"""
        from jira_extractor.cli import main
        
        # Setup parser mock
        mock_parser = Mock()
        mock_create_parser.return_value = mock_parser
        
        mock_args = Mock()
        mock_args.url = 'https://jira.example.com'
        mock_args.issue = 'ROOT-1'
        mock_args.bearer_token = 'abc123'
        mock_args.token = None
        mock_args.username = None
        mock_args.password = None
        mock_args.output = './output'
        mock_args.overwrite = True
        mock_args.expand = 'comments'
        mock_args.debug = False
        mock_args.descendant_depth = 'all'
        mock_args.include_subtasks = True
        mock_args.include_links = True
        mock_args.include_remote_links = False
        mock_parser.parse_args.return_value = mock_args
        
        # Setup client mock
        mock_client_instance = Mock()
        mock_jira_client.return_value = mock_client_instance
        
        # Mock descendants data
        descendants_data = {
            "ROOT-1": {"key": "ROOT-1"},
            "CHILD-1": {"key": "CHILD-1"},
            "GRANDCHILD-1": {"key": "GRANDCHILD-1"},
            "_extraction_metadata": {"start_issue": "ROOT-1", "max_depth": -1}
        }
        mock_client_instance.get_descendants.return_value = descendants_data
        mock_client_instance.test_connection.return_value = {"displayName": "Test User"}
        
        main()
        
        # Verify get_descendants called with unlimited depth
        mock_client_instance.get_descendants.assert_called_once_with(
            'ROOT-1',
            depth=-1,
            include_subtasks=True,
            include_links=True,
            include_remote_links=False,
            expand='comments'
        )

    @patch('jira_extractor.cli.create_parser')
    @patch('jira_extractor.cli.JiraClient')
    @patch('sys.stderr', new_callable=io.StringIO)
    def test_main_descendant_no_issues_extracted(self, mock_stderr, mock_jira_client, mock_create_parser):
        """Test main function when no issues are extracted"""
        from jira_extractor.cli import main
        
        # Setup parser mock
        mock_parser = Mock()
        mock_create_parser.return_value = mock_parser
        
        mock_args = Mock()
        mock_args.url = 'https://jira.example.com'
        mock_args.issue = 'MISSING-1'
        mock_args.bearer_token = 'abc123'
        mock_args.token = None
        mock_args.username = None
        mock_args.password = None
        mock_args.output = '-'
        mock_args.overwrite = False
        mock_args.expand = None
        mock_args.debug = False
        mock_args.descendant_depth = '1'
        mock_args.include_subtasks = True
        mock_args.include_links = False
        mock_args.include_remote_links = False
        mock_parser.parse_args.return_value = mock_args
        
        # Setup client mock - return empty result
        mock_client_instance = Mock()
        mock_jira_client.return_value = mock_client_instance
        mock_client_instance.get_descendants.return_value = {"_extraction_metadata": {}}
        mock_client_instance.test_connection.return_value = {"displayName": "Test User"}
        
        with self.assertRaises(SystemExit) as cm:
            main()
        
        self.assertEqual(cm.exception.code, 1)

    @patch('jira_extractor.cli.create_parser')
    @patch('jira_extractor.cli.JiraClient')
    @patch('jira_extractor.cli.write_output')
    def test_main_single_issue_mode_fallback(self, mock_write_output, mock_jira_client, mock_create_parser):
        """Test main function falls back to single issue mode when no descendant options"""
        from jira_extractor.cli import main
        
        # Setup parser mock with no descendant options
        mock_parser = Mock()
        mock_create_parser.return_value = mock_parser
        
        mock_args = Mock()
        mock_args.url = 'https://jira.example.com'
        mock_args.issue = 'TEST-123'
        mock_args.bearer_token = 'abc123'
        mock_args.token = None
        mock_args.username = None
        mock_args.password = None
        mock_args.output = '-'
        mock_args.overwrite = False
        mock_args.expand = None
        mock_args.debug = False
        mock_args.descendant_depth = '0'  # Default value
        mock_args.include_subtasks = False
        mock_args.include_links = False
        mock_args.include_remote_links = False
        mock_parser.parse_args.return_value = mock_args
        
        # Setup client mock
        mock_client_instance = Mock()
        mock_jira_client.return_value = mock_client_instance
        mock_client_instance.get_issue.return_value = {"key": "TEST-123", "fields": {"summary": "Test Issue"}}
        mock_client_instance.test_connection.return_value = {"displayName": "Test User"}
        
        main()
        
        # Verify single issue mode is used
        mock_client_instance.get_issue.assert_called_once_with('TEST-123', expand=None)
        mock_write_output.assert_called_once()
        
        # Verify descendants method is NOT called
        mock_client_instance.get_descendants.assert_not_called()

    @patch('jira_extractor.cli.create_parser')
    def test_main_invalid_depth_parameter(self, mock_create_parser):
        """Test main function with invalid depth parameter"""
        from jira_extractor.cli import main
        
        # Setup parser mock
        mock_parser = Mock()
        mock_create_parser.return_value = mock_parser
        
        mock_args = Mock()
        mock_args.url = 'https://jira.example.com'
        mock_args.issue = 'TEST-123'
        mock_args.bearer_token = 'abc123'
        mock_args.descendant_depth = 'invalid'
        mock_parser.parse_args.return_value = mock_args
        
        with patch('sys.stderr', new_callable=io.StringIO) as mock_stderr:
            with self.assertRaises(SystemExit) as cm:
                main()
            
            self.assertEqual(cm.exception.code, 1)
            self.assertIn("Invalid depth value: invalid", mock_stderr.getvalue())


if __name__ == '__main__':
    unittest.main() 
