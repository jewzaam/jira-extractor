#!/usr/bin/env python3
# Generated by: Cursor (Claude)
"""
Unit tests for JIRA Extractor CLI

Copyright (C) 2025 Naveen Z. Malik
This program is licensed under GPL-3.0-or-later
"""

import unittest
from unittest.mock import Mock, patch, mock_open
import json
import sys

from .cli import (
    setup_logging, validate_url, write_output, create_parser, main
)


class TestCLIFunctions(unittest.TestCase):
    """Test cases for CLI utility functions"""
    
    def setUp(self):
        """Set up test fixtures"""
        self.test_url = "https://test.jira.com"
        self.test_issue_key = "TEST-123"
        self.test_data = {
            "key": self.test_issue_key,
            "fields": {
                "summary": "Test Issue Summary",
                "description": "Test description"
            }
        }
    
    @patch('jira_extractor.cli.logging.basicConfig')
    def test_setup_logging_info_level(self, mock_basic_config):
        """Test logging setup with INFO level"""
        setup_logging(debug=False)
        
        mock_basic_config.assert_called_once()
        call_args = mock_basic_config.call_args
        self.assertEqual(call_args[1]['level'], 20)  # logging.INFO
        self.assertIn('%(levelname)s: %(message)s', call_args[1]['format'])
    
    @patch('jira_extractor.cli.logging.basicConfig')
    def test_setup_logging_debug_level(self, mock_basic_config):
        """Test logging setup with DEBUG level"""
        setup_logging(debug=True)
        
        mock_basic_config.assert_called_once()
        call_args = mock_basic_config.call_args
        self.assertEqual(call_args[1]['level'], 10)  # logging.DEBUG
        self.assertIn('%(asctime)s - %(levelname)s: %(message)s', call_args[1]['format'])
    
    def test_validate_url_with_scheme(self):
        """Test URL validation with existing scheme"""
        url = "https://jira.example.com"
        result = validate_url(url)
        self.assertEqual(result, url)
    
    def test_validate_url_without_scheme(self):
        """Test URL validation adds https scheme"""
        url = "jira.example.com"
        result = validate_url(url)
        self.assertEqual(result, f"https://{url}")
    
    def test_validate_url_invalid(self):
        """Test URL validation with invalid URL"""
        with self.assertRaises(ValueError) as cm:
            validate_url("")
        self.assertIn("Invalid URL", str(cm.exception))
    
    @patch('builtins.print')
    def test_write_output_stdout(self, mock_print):
        """Test writing output to stdout"""
        write_output(self.test_data, "-", self.test_issue_key)
        
        mock_print.assert_called_once()
        printed_output = mock_print.call_args[0][0]
        parsed_output = json.loads(printed_output)
        self.assertEqual(parsed_output["key"], self.test_issue_key)
    
    @patch('builtins.print')
    def test_write_output_stdout_explicit(self, mock_print):
        """Test writing output to stdout with explicit 'stdout'"""
        write_output(self.test_data, "stdout", self.test_issue_key)
        
        mock_print.assert_called_once()
        printed_output = mock_print.call_args[0][0]
        parsed_output = json.loads(printed_output)
        self.assertEqual(parsed_output["key"], self.test_issue_key)
    
    @patch('builtins.open', new_callable=mock_open)
    @patch('os.makedirs')
    @patch('os.path.exists')
    @patch('builtins.print')
    def test_write_output_file_new(self, mock_print, mock_exists, mock_makedirs, mock_file):
        """Test writing output to new file"""
        mock_exists.return_value = False
        output_dir = "/test/output"
        
        write_output(self.test_data, output_dir, self.test_issue_key)
        
        # Verify directory creation
        mock_makedirs.assert_called_once_with(output_dir, exist_ok=True)
        
        # Verify file creation
        expected_path = f"{output_dir}/{self.test_issue_key}.json"
        mock_file.assert_called_once_with(expected_path, 'w', encoding='utf-8')
        
        # Verify file content
        written_content = "".join(call[0][0] for call in mock_file().write.call_args_list)
        parsed_content = json.loads(written_content)
        self.assertEqual(parsed_content["key"], self.test_issue_key)
        
        # Verify success message
        mock_print.assert_called_once_with(f"Issue {self.test_issue_key} saved to {expected_path}")
    
    @patch('os.makedirs')
    @patch('os.path.exists')
    def test_write_output_file_exists_no_overwrite(self, mock_exists, mock_makedirs):
        """Test writing output to existing file without overwrite flag"""
        mock_exists.return_value = True
        output_dir = "/test/output"
        
        with self.assertRaises(Exception) as cm:
            write_output(self.test_data, output_dir, self.test_issue_key, overwrite=False)
        
        self.assertIn("already exists", str(cm.exception))
        self.assertIn("--overwrite", str(cm.exception))
    
    @patch('builtins.open', new_callable=mock_open)
    @patch('os.makedirs')
    @patch('os.path.exists')
    @patch('builtins.print')
    def test_write_output_file_exists_with_overwrite(self, mock_print, mock_exists, mock_makedirs, mock_file):
        """Test writing output to existing file with overwrite flag"""
        mock_exists.return_value = True
        output_dir = "/test/output"
        
        write_output(self.test_data, output_dir, self.test_issue_key, overwrite=True)
        
        # Should still proceed and write the file
        expected_path = f"{output_dir}/{self.test_issue_key}.json"
        mock_file.assert_called_once_with(expected_path, 'w', encoding='utf-8')


class TestArgumentParser(unittest.TestCase):
    """Test cases for argument parser configuration"""
    
    def setUp(self):
        """Set up test fixtures"""
        self.parser = create_parser()
    
    def test_parser_required_args(self):
        """Test parser with required arguments"""
        args = self.parser.parse_args([
            '-u', 'https://jira.example.com',
            '-i', 'TEST-123'
        ])
        
        self.assertEqual(args.url, 'https://jira.example.com')
        self.assertEqual(args.issue, 'TEST-123')
    
    def test_parser_missing_url(self):
        """Test parser with missing required URL"""
        with self.assertRaises(SystemExit):
            self.parser.parse_args(['-i', 'TEST-123'])
    
    def test_parser_missing_issue(self):
        """Test parser with missing required issue"""
        with self.assertRaises(SystemExit):
            self.parser.parse_args(['-u', 'https://jira.example.com'])
    
    def test_parser_bearer_token(self):
        """Test parser with bearer token authentication"""
        args = self.parser.parse_args([
            '-u', 'https://jira.example.com',
            '-i', 'TEST-123',
            '--bearer-token', 'abc123'
        ])
        
        self.assertEqual(args.bearer_token, 'abc123')
    
    def test_parser_token_auth(self):
        """Test parser with API token authentication"""
        args = self.parser.parse_args([
            '-u', 'https://jira.example.com',
            '-i', 'TEST-123',
            '--username', 'testuser',
            '--token', 'token123'
        ])
        
        self.assertEqual(args.username, 'testuser')
        self.assertEqual(args.token, 'token123')
    
    def test_parser_password_auth(self):
        """Test parser with password authentication"""
        args = self.parser.parse_args([
            '-u', 'https://jira.example.com',
            '-i', 'TEST-123',
            '--username', 'testuser',
            '--password', 'pass123'
        ])
        
        self.assertEqual(args.username, 'testuser')
        self.assertEqual(args.password, 'pass123')
    
    def test_parser_output_options(self):
        """Test parser with output options"""
        args = self.parser.parse_args([
            '-u', 'https://jira.example.com',
            '-i', 'TEST-123',
            '-o', './output',
            '--overwrite'
        ])
        
        self.assertEqual(args.output, './output')
        self.assertTrue(args.overwrite)
    
    def test_parser_field_options(self):
        """Test parser with field expansion options"""
        args = self.parser.parse_args([
            '-u', 'https://jira.example.com',
            '-i', 'TEST-123',
            '--expand', 'changelog,comments'
        ])
        
        self.assertEqual(args.expand, 'changelog,comments')
    
    def test_parser_debug_option(self):
        """Test parser with debug option"""
        args = self.parser.parse_args([
            '-u', 'https://jira.example.com',
            '-i', 'TEST-123',
            '--debug'
        ])
        
        self.assertTrue(args.debug)


class TestMainFunction(unittest.TestCase):
    """Test cases for main function"""
    
    @patch('jira_extractor.cli.JiraClient')
    @patch('jira_extractor.cli.write_output')
    @patch('jira_extractor.cli.setup_logging')
    @patch('sys.argv')
    def test_main_bearer_auth_success(self, mock_argv, mock_setup_logging, mock_write_output, mock_jira_client):
        """Test main function with successful bearer authentication"""
        # Setup command line arguments
        mock_argv.__getitem__.side_effect = lambda x: [
            'jira_extractor.py',
            '-u', 'https://jira.example.com',
            '-i', 'TEST-123',
            '--bearer-token', 'abc123'
        ][x]
        mock_argv.__len__.return_value = 5
        
        # Setup mocks
        mock_client_instance = Mock()
        mock_client_instance.get_issue.return_value = {"key": "TEST-123"}
        mock_jira_client.return_value = mock_client_instance
        
        with patch('argparse.ArgumentParser.parse_args') as mock_parse_args:
            mock_args = Mock()
            mock_args.url = 'https://jira.example.com'
            mock_args.issue = 'TEST-123'
            mock_args.bearer_token = 'abc123'
            mock_args.token = None
            mock_args.username = None
            mock_args.password = None
            mock_args.output = '-'
            mock_args.overwrite = False
            mock_args.expand = None
            mock_args.debug = False
            mock_parse_args.return_value = mock_args
            
            main()
            
            # Verify client creation
            mock_jira_client.assert_called_once_with(
                'https://jira.example.com',
                'bearer',
                token='abc123'
            )
            
            # Verify issue retrieval
            mock_client_instance.get_issue.assert_called_once_with('TEST-123', expand=None)
            
            # Verify output writing
            mock_write_output.assert_called_once()
    
    @patch('jira_extractor.cli.JiraClient')
    @patch('jira_extractor.cli.setup_logging')
    @patch('sys.argv')
    @patch('builtins.print')
    def test_main_token_auth_missing_username(self, mock_print, mock_argv, mock_setup_logging, mock_jira_client):
        """Test main function with token auth but missing username"""
        mock_argv.__getitem__.side_effect = lambda x: [
            'jira_extractor.py',
            '-u', 'https://jira.example.com',
            '-i', 'TEST-123',
            '--token', 'abc123'
        ][x]
        mock_argv.__len__.return_value = 5
        
        with patch('argparse.ArgumentParser.parse_args') as mock_parse_args:
            mock_args = Mock()
            mock_args.url = 'https://jira.example.com'
            mock_args.issue = 'TEST-123'
            mock_args.bearer_token = None
            mock_args.token = 'abc123'
            mock_args.username = None
            mock_args.password = None
            mock_args.debug = False
            mock_parse_args.return_value = mock_args
            
            with self.assertRaises(SystemExit):
                main()
            
            # Verify error message
            mock_print.assert_called_with(
                "Error: --username is required when using --token",
                file=sys.stderr
            )
    
    @patch('jira_extractor.cli.JiraClient')
    @patch('jira_extractor.cli.setup_logging')
    @patch('sys.argv')
    @patch('builtins.print')
    def test_main_no_auth_public_issue(self, mock_print, mock_argv, mock_setup_logging, mock_jira_client):
        """Test main function with no authentication for public issue"""
        mock_argv.__getitem__.side_effect = lambda x: [
            'jira_extractor.py',
            '-u', 'https://issues.redhat.com',
            '-i', 'RFE-7877'
        ][x]
        mock_argv.__len__.return_value = 3
        
        # Setup mocks
        mock_client_instance = Mock()
        mock_client_instance.get_issue.return_value = {"key": "RFE-7877"}
        mock_jira_client.return_value = mock_client_instance
        
        with patch('argparse.ArgumentParser.parse_args') as mock_parse_args, \
             patch('jira_extractor.cli.write_output') as mock_write_output:
            mock_args = Mock()
            mock_args.url = 'https://issues.redhat.com'
            mock_args.issue = 'RFE-7877'
            mock_args.bearer_token = None
            mock_args.token = None
            mock_args.username = None
            mock_args.password = None
            mock_args.output = '-'
            mock_args.overwrite = False
            mock_args.expand = None
            mock_args.debug = False
            mock_parse_args.return_value = mock_args
            
            main()
            
            # Verify client creation with no auth
            mock_jira_client.assert_called_once_with(
                'https://issues.redhat.com',
                None
            )
            
            # Verify no connection test was performed
            mock_client_instance.test_connection.assert_not_called()
            
            # Verify output was written
            mock_write_output.assert_called_once()
    
    @patch('jira_extractor.cli.validate_url')
    @patch('jira_extractor.cli.setup_logging')
    @patch('sys.argv')
    @patch('builtins.print')
    def test_main_invalid_url(self, mock_print, mock_argv, mock_setup_logging, mock_validate_url):
        """Test main function with invalid URL"""
        mock_validate_url.side_effect = ValueError("Invalid URL: bad-url")
        
        with patch('argparse.ArgumentParser.parse_args') as mock_parse_args:
            mock_args = Mock()
            mock_args.url = 'bad-url'
            mock_args.debug = False
            mock_parse_args.return_value = mock_args
            
            with self.assertRaises(SystemExit):
                main()
            
            # Verify error message
            mock_print.assert_called_with(
                "Error: Invalid URL: bad-url",
                file=sys.stderr
            )


if __name__ == '__main__':
    unittest.main() 