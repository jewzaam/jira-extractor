# flake8: noqa: E501
from __future__ import annotations

"""MCP JIRA Server

A read-only Model Context Protocol server that provides tools for:
1. Searching JIRA using simple JQL queries or plain text.
2. Fetching a single JIRA issue by key.
3. Returning a hint describing the expected JIRA issue identifier format.

The implementation is intentionally lightweight and builds on the existing
`jira_extractor.client.JiraClient` that already handles authentication and
basic REST interactions.

Transport: stdio (recommended for local development)
Dependencies:
  * mcp[cli]      – FastMCP implementation and CLI helpers
  * requests      – Already required by jira_extractor

Generated by: Cursor (Claude)
"""

from typing import List, Dict, Any, Optional
import asyncio
import logging
from urllib.parse import urljoin

from pydantic import BaseModel, Field

from .config import load_config, ConfigError

try:
    from mcp.server.fastmcp import FastMCP
    from mcp.types import ToolAnnotations
except ImportError as exc:  # pragma: no cover – avoids breaking tests when mcp missing
    raise SystemExit(
        "The `mcp` package is required to run the MCP JIRA server.\n"
        "Install dependencies first:  pip install -r requirements.txt"
    ) from exc

from jira_extractor.client import JiraClient


###############################################################################
# Data models returned by tools                                                #
###############################################################################

class IssueSummary(BaseModel):
    """Minimal representation of a JIRA issue suitable for search results."""

    key: str = Field(..., title="JIRA issue key", examples=["ABC-123"])
    summary: str = Field(..., title="Issue summary/title")
    status: str = Field(..., title="Status name", examples=["In Progress"])
    url: str = Field(..., title="Direct URL to the issue in the browser")

    model_config = {
        "title": "IssueSummary",
        "extra": "ignore",
    }


class IssueDetails(BaseModel):
    """Subset of fields from the full JIRA issue useful for conversational use.

    The *raw* field allows callers to access the complete response in case they
    need additional data not exposed explicitly.
    """

    key: str = Field(..., title="JIRA issue key")
    summary: str = Field(..., title="Summary/title of the issue")
    description: Optional[str] = Field(None, title="Issue description")
    status: str = Field(..., title="Workflow status name")
    raw: Dict[str, Any] = Field(..., title="Full unmodified JIRA API response")

    model_config = {
        "title": "IssueDetails",
        "extra": "ignore",
    }


###############################################################################
# Tools implementation                                                         #
###############################################################################

class JiraTools:
    """Collection of MCP *tools* backed by :class:`JiraClient`."""

    def __init__(self, client: JiraClient):
        self._client = client
        self._logger = logging.getLogger(__name__).getChild("JiraTools")

    # ---------------------------------------------------------------------
    # Search
    # ---------------------------------------------------------------------
    async def search_issues(self, query: str, max_results: int = 25) -> List[IssueSummary]:
        """Search the JIRA instance for issues.

        The *query* parameter accepts either full JQL (e.g. `project = ABC AND text ~ "foo"`) or a
        free-text term (e.g. `RFE-7877`).  If the query does **not** contain a space or an `=` sign
        we treat it as a simple free-text search using the *summary* field.
        """

        # Heuristic – detect if the user likely provided JQL. Very naive but good enough for hinting.
        is_jql = "=" in query or "order by" in query.lower() or " AND " in query or " OR " in query

        if is_jql:
            jql = query
        else:
            # Use summary ~ "..." for simple search to avoid full-text side-effects.
            term = query.replace("\"", "\\\"")
            jql = f'summary ~ "{term}"'

        url = urljoin(self._client.api_base, "search")
        params = {
            "jql": jql,
            "fields": "key,summary,status",
            "maxResults": max(1, min(max_results, 100)),
        }

        self._logger.info("JIRA search: %s", jql)
        response = self._client._make_api_request(url, params=params, resource_name="search results")

        summaries: List[IssueSummary] = []
        for issue in response.get("issues", []):
            key = issue.get("key")
            fields = issue.get("fields", {})
            summary = fields.get("summary", "")
            status = fields.get("status", {}).get("name", "")
            summaries.append(
                IssueSummary(
                    key=key,
                    summary=summary,
                    status=status,
                    url=f"{self._client.base_url}/browse/{key}",
                )
            )

        return summaries

    # ------------------------------------------------------------------
    # Get single issue
    # ------------------------------------------------------------------
    async def get_issue(self, key: str, expand: Optional[str] = None) -> IssueDetails:
        """Fetch a single JIRA issue by key."""
        issue = self._client.get_issue(key, expand=expand)
        fields = issue.get("fields", {})
        details = IssueDetails(
            key=issue.get("key"),
            summary=fields.get("summary", ""),
            description=fields.get("description"),
            status=fields.get("status", {}).get("name", ""),
            raw=issue,
        )
        return details

    # ------------------------------------------------------------------
    # Identifier hint
    # ------------------------------------------------------------------
    async def identifier_hint(self) -> str:
        """Return a short description of valid JIRA identifier structure."""
        return (
            "JIRA issue identifiers follow the pattern `<PROJECT>-<NUMBER>`, where `<PROJECT>` "
            "is an uppercase project key consisting of letters (e.g., `RFE`) and `<NUMBER>` is "
            "a positive integer (e.g., `7877`).  Example: `RFE-7877`."
        )


###############################################################################
# Server factory                                                               #
###############################################################################

def create_server(
    *,
    url: str,
    username: Optional[str] = None,
    password: Optional[str] = None,
    token: Optional[str] = None,
    bearer_token: Optional[str] = None,
) -> FastMCP:
    """Create and configure a FastMCP server instance."""

    logging.basicConfig(level=logging.INFO)

    client = JiraClient(
        base_url=url,
        username=username,
        password=password,
        token=token,
        bearer_token=bearer_token,
    )

    mcp = FastMCP(
        name="JIRA Read-Only MCP Server",
        instructions=(
            "You are a helpful assistant that provides access to read-only JIRA information. "
            "Use the search and get_issue tools to help users retrieve issue data."
        ),
    )

    tools = JiraTools(client)

    # ------------------------------------------------------------------
    # Register tools                                                    #
    # ------------------------------------------------------------------

    @mcp.tool(
        name="search_issues",
        description=(
            "Search JIRA for issues. Accepts either full JQL or a simple search term. "
            "Returns a list of matching issues with key, summary, status, and URL."
        ),
        annotations=ToolAnnotations(
            readOnlyHint=True,
            destructiveHint=False,
            idempotentHint=True,
            openWorldHint=False,
        ),
    )
    async def search_issues_tool(query: str, max_results: int = 25) -> List[IssueSummary]:
        return await tools.search_issues(query, max_results)

    @mcp.tool(
        name="get_issue",
        description="Retrieve detailed information for a single JIRA issue.",
        annotations=ToolAnnotations(
            readOnlyHint=True,
            destructiveHint=False,
            idempotentHint=True,
            openWorldHint=False,
        ),
    )
    async def get_issue_tool(key: str, expand: Optional[str] = None) -> IssueDetails:
        return await tools.get_issue(key, expand)

    @mcp.tool(
        name="identifier_hint",
        description="Return a short text explaining the PROJECT-NUMBER pattern (e.g., RFE-7877).",
        annotations=ToolAnnotations(
            readOnlyHint=True,
            destructiveHint=False,
            idempotentHint=True,
            openWorldHint=False,
        ),
    )
    async def identifier_hint_tool() -> str:
        return await tools.identifier_hint()

    return mcp


###############################################################################
# CLI entry-point                                                             #
###############################################################################

async def _async_main() -> None:
    """Entry-point that loads configuration then starts the server."""
    import argparse

    parser = argparse.ArgumentParser(
        description="Run the JIRA MCP server (stdio transport). Arguments override config file values.",
        add_help=True,
    )
    parser.add_argument(
        "-c",
        "--config",
        help="Path to YAML/JSON configuration file (default: mcp_jira_server.yaml).",
        default=None,
    )
    parser.add_argument("--url", help="JIRA base URL")
    parser.add_argument("--username", help="JIRA username (for password/token auth)")
    parser.add_argument("--password", help="JIRA password (basic auth)")
    parser.add_argument("--token", help="JIRA API token (basic auth)")
    parser.add_argument("--bearer-token", help="Personal Access Token (Bearer auth)")

    args = parser.parse_args()

    cfg = load_config(args.config)

    # Use CLI arguments to override any config-file values
    url = args.url or cfg.get("url")
    username = args.username or cfg.get("username")
    password = args.password or cfg.get("password")
    token = args.token or cfg.get("token")
    bearer_token = args.bearer_token or cfg.get("bearer_token")

    if not url:
        raise ConfigError(
            "JIRA 'url' must be provided either via configuration file or --url argument."
        )

    server = create_server(
        url=url,
        username=username,
        password=password,
        token=token,
        bearer_token=bearer_token,
    )

    await server.run_async()  # Use the async version


def main() -> None:  # pragma: no cover
    """Synchronous wrapper for CLI entry-point."""
    import asyncio
    try:
        server = None
        
        # Parse args and create server synchronously
        import argparse
        parser = argparse.ArgumentParser(
            description="Run the JIRA MCP server (stdio transport). Arguments override config file values.",
            add_help=True,
        )
        parser.add_argument(
            "-c",
            "--config",
            help="Path to YAML/JSON configuration file (default: mcp_jira_server.yaml).",
            default=None,
        )
        parser.add_argument("--url", help="JIRA base URL")
        parser.add_argument("--username", help="JIRA username (for password/token auth)")
        parser.add_argument("--password", help="JIRA password (basic auth)")
        parser.add_argument("--token", help="JIRA API token (basic auth)")
        parser.add_argument("--bearer-token", help="Personal Access Token (Bearer auth)")

        args = parser.parse_args()

        cfg = load_config(args.config)

        # Use CLI arguments to override any config-file values
        url = args.url or cfg.get("url")
        username = args.username or cfg.get("username")
        password = args.password or cfg.get("password")
        token = args.token or cfg.get("token")
        bearer_token = args.bearer_token or cfg.get("bearer_token")

        if not url:
            raise ConfigError(
                "JIRA 'url' must be provided either via configuration file or --url argument."
            )

        server = create_server(
            url=url,
            username=username,
            password=password,
            token=token,
            bearer_token=bearer_token,
        )

        # Run synchronously
        server.run()  # Use the sync version
        
    except KeyboardInterrupt:
        pass


if __name__ == "__main__":  # pragma: no cover
    main() 